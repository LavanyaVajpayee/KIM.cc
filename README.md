
One of the most challenging problems I solved recently was while building my Expense Tracker app. The issue started when I integrated Firebase Authentication, Cloudinary image uploads, and the analytics dashboard together. Individually, each module worked fine, but once users started uploading profile images and adding transactions quickly, the app began slowing down and sometimes even freezing on lower-end devices. The biggest challenge was identifying the root cause because everything looked correct at first glance. After digging deeper, I realized that the image pipeline wasnâ€™t being cached efficiently, so every time a user refreshed the dashboard, the app fetched full-resolution images and recalculated analytics from scratch. I redesigned the flow by adding optimized caching, compressing uploads, and restructuring the transaction data fetch using batched listeners. This not only solved the lag but also improved the overall user experience pages now load instantly, and the weekly analytics feel much smoother. It was one of those problems that taught me how real world performance bottlenecks often come from the interaction of multiple components, not just one piece of code.
